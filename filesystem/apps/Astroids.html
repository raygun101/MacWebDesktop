<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Retro Vector Asteroids</title>
  <link rel="icon" href="Asteroids.png">
  <style>
    /* Global Styles */
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: sans-serif;
    }
    canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
    }
    /* CRT / Scanline Effect */
    .crt {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: 50;
    }
    .crt::after {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        linear-gradient(black 50%, transparent 50%),
        linear-gradient(90deg, black 50%, transparent 50%);
      background-size: 100% 2px, 3px 100%;
      opacity: 0.15;
    }
    /* UI Overlays */
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: rgba(0, 0, 0, 0.85);
      color: #0f0;
      z-index: 100;
    }
    .overlay h1 {
      margin: 0 0 20px;
      font-size: 3em;
    }
    .overlay button {
      padding: 10px 20px;
      font-size: 1em;
      background: #111;
      border: 1px solid #0f0;
      color: #0f0;
      cursor: pointer;
      margin: 5px;
    }
  </style>
</head>
<body>
  <!-- Game Canvas -->
  <canvas id="gameCanvas"></canvas>
  <!-- CRT overlay -->
  <div class="crt"></div>
  <!-- UI Overlays -->
  <div id="startScreen" class="overlay">
    <h1>Retro Vector Asteroids</h1>
    <button id="startBtn">Start Game</button>
  </div>
  <div id="gameOverScreen" class="overlay" style="display: none;">
    <h1>Game Over</h1>
    <button id="restartBtn">Restart</button>
    <button id="creditsBtn">Credits</button>
  </div>
  <div id="creditsScreen" class="overlay" style="display: none;">
    <h1>Credits</h1>
    <p>Developed by Your Name</p>
    <button id="backToMenuBtn">Back to Menu</button>
  </div>
  
  <script>
    (function(){
      /***** Global Configuration *****/
      const config = {
        ship: {
          acceleration: 0.15,
          drag: 0.98,
          maxVelocity: 7,
          rotationSpeed: 0.1
        },
        bullet: {
          speed: 7,
          life: 60
        },
        asteroid: {
          initialCount: 5,
          defaultRadius: 40
        },
        particles: {
          thruster: {
            count: 3,       // particles per frame when thrusting
            life: 20,
            color: "blue",
            speed: 2,
            size: 2
          },
          explosion: {
            count: 40,
            life: 40,
            color: "#0f0",  // explosion debris
            speed: 3,
            size: 2
          },
          shipExplosion: {
            count: 60,
            ringLife: 80,   // frames for explosion/beam effect
            color: "#00f",  // blue rings for beam-in
            lineWidth: 4
          }
        },
        ufo: {
          speed: 2,
          shootCooldown: 120, // frames between shots
          scoreValue: 50
        },
        score: {
          font: "30px Courier",
          color: "#0f0"
        },
        sounds: {
          bullet: { frequency: 600, type: "square", duration: 0.1, volume: 0.3 },
          asteroidExplosion: { frequency: 200, type: "triangle", duration: 0.2, volume: 0.5 },
          ufoShoot: { frequency: 400, type: "square", duration: 0.1, volume: 0.3 },
          ufoExplosion: { frequency: 250, type: "sawtooth", duration: 0.2, volume: 0.5 },
          shipExplosion: { frequency: 100, type: "sine", duration: 0.3, volume: 0.5 },
          thrust: { frequency: 300, type: "sine", volume: 0.2 }, // sustained thrust sound
          background: { frequency: 50, type: "sawtooth", volume: 0.1 } // background loop sound
        }
      };

      /***** Helper Functions *****/
      // Shorter selector function
      function select(id) {
        return document.getElementById(id);
      }
      // on() helper to attach event listeners
      function on(selector, event, callback) {
        select(selector).addEventListener(event, callback);
      }

      /***** Extended Oscillator Class for 8-bit Sounds *****/
      class Oscillator {
        constructor() {
          this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          // Store sustained sound sources by ID
          this.sustainedSources = {};
        }
        playSound(frequency, type, duration, volume = 0.5) {
          const osc = this.audioCtx.createOscillator();
          const gainNode = this.audioCtx.createGain();
          osc.frequency.value = frequency;
          osc.type = type;
          osc.connect(gainNode);
          gainNode.connect(this.audioCtx.destination);
          gainNode.gain.value = volume;
          osc.start();
          osc.stop(this.audioCtx.currentTime + duration);
        }
        // Starts a sustained sound if not already playing.
        startSustainedSound(id, frequency, type, volume = 0.5) {
          if (!this.sustainedSources[id]) {
            let osc = this.audioCtx.createOscillator();
            let gainNode = this.audioCtx.createGain();
            osc.frequency.value = frequency;
            osc.type = type;
            osc.connect(gainNode);
            gainNode.connect(this.audioCtx.destination);
            gainNode.gain.value = volume;
            osc.start();
            this.sustainedSources[id] = { osc, gainNode };
          }
        }
        // Stops a sustained sound by ID.
        stopSustainedSound(id) {
          if (this.sustainedSources[id]) {
            this.sustainedSources[id].osc.stop();
            delete this.sustainedSources[id];
          }
        }
      }
      const osc = new Oscillator();

      /***** Setup Canvas *****/
      const canvas = select("gameCanvas");
      const ctx = canvas.getContext("2d");
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);

      /***** Global Game State *****/
      let gameState = "start"; // "start", "starting", "playing", "gameover"
      let score = 0;
      const keys = {};
      document.addEventListener("keydown", (e) => { keys[e.key] = true; });
      document.addEventListener("keyup", (e) => { keys[e.key] = false; });

      /***** Parallax Starfield *****/
      let starLayers = [];
      function initStars() {
        starLayers = [];
        const layersConfig = [
          { count: 100, speed: 0.6, baseAlpha: 1.0, sizeRange: [1,2] },
          { count: 75, speed: 0.4, baseAlpha: 0.7, sizeRange: [1,1.5] },
          { count: 50, speed: 0.2, baseAlpha: 0.5, sizeRange: [0.8,1.2] },
          { count: 30, speed: 0.1, baseAlpha: 0.3, sizeRange: [0.5,1.0] }
        ];
        layersConfig.forEach(layer => {
          const stars = [];
          for(let i = 0; i < layer.count; i++){
            stars.push({
              x: Math.random() * canvas.width,
              y: Math.random() * canvas.height,
              radius: Math.random() * (layer.sizeRange[1] - layer.sizeRange[0]) + layer.sizeRange[0],
              speedFactor: layer.speed,
              baseAlpha: layer.baseAlpha,
              phase: Math.random() * Math.PI * 2
            });
          }
          starLayers.push(stars);
        });
      }
      initStars();
      function updateStars() {
        if(ship) {
          starLayers.forEach(stars => {
            stars.forEach(star => {
              star.x -= ship.velocity.x * star.speedFactor;
              star.y -= ship.velocity.y * star.speedFactor;
              if(star.x < 0) star.x = canvas.width;
              if(star.x > canvas.width) star.x = 0;
              if(star.y < 0) star.y = canvas.height;
              if(star.y > canvas.height) star.y = 0;
            });
          });
        }
      }
      function drawStars() {
        starLayers.forEach(stars => {
          stars.forEach(star => {
            const twinkle = star.baseAlpha + 0.2 * Math.sin(Date.now()/500 + star.phase);
            ctx.fillStyle = "rgba(255,255,255," + twinkle + ")";
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.radius, 0, Math.PI*2);
            ctx.fill();
          });
        });
      }

      /***** Particle Class *****/
      class Particle {
        constructor(x, y, angle, speed, life, color, size) {
          this.x = x;
          this.y = y;
          this.angle = angle;
          this.speed = speed;
          this.life = life;
          this.maxLife = life;
          this.color = color;
          this.size = size;
          this.alpha = 1;
        }
        update() {
          this.x += Math.cos(this.angle) * this.speed;
          this.y += Math.sin(this.angle) * this.speed;
          this.life--;
          this.alpha = this.life / this.maxLife;
          this.size *= 0.99;
        }
        draw() {
          ctx.save();
          ctx.globalAlpha = this.alpha;
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 5;
          ctx.shadowColor = this.color;
          ctx.fill();
          ctx.restore();
        }
      }

      /***** Ring Effect Class *****/
      // Modified to support reverse mode (for beam-in)
      class Ring {
        constructor(x, y, initialRadius, finalRadius, life, color, lineWidth, reverse = false) {
          this.x = x;
          this.y = y;
          this.initialRadius = initialRadius;
          this.finalRadius = finalRadius;
          this.life = life;
          this.maxLife = life;
          this.color = color;
          this.lineWidth = lineWidth;
          this.reverse = reverse;
          this.rotation = Math.random() * Math.PI * 2;
          this.rotationSpeed = (Math.random() - 0.5) * 0.1;
        }
        update() {
          if (!this.reverse) {
            let progress = 1 - this.life / this.maxLife;
            this.radius = progress * this.finalRadius;
          } else {
            // Reverse: shrink from a large radius down to a small one (usually 0)
            let progress = this.life / this.maxLife;
            this.radius = this.finalRadius + progress * (this.initialRadius - this.finalRadius);
          }
          this.life--;
          this.rotation += this.rotationSpeed;
        }
        draw() {
          ctx.save();
          ctx.strokeStyle = this.color;
          ctx.lineWidth = this.lineWidth;
          ctx.globalAlpha = this.life / this.maxLife;
          ctx.shadowBlur = 10;
          ctx.shadowColor = this.color;
          ctx.beginPath();
          const segments = 12;
          for (let i = 0; i < segments; i++) {
            const startAngle = (i / segments) * Math.PI * 2 + this.rotation;
            const endAngle = ((i + 0.8) / segments) * Math.PI * 2 + this.rotation;
            ctx.arc(this.x, this.y, this.radius, startAngle, endAngle);
          }
          ctx.stroke();
          ctx.restore();
        }
      }

      /***** Global Game Object Arrays *****/
      let ship, asteroids = [], bullets = [], particles = [], effects = [];

      /***** Ship Class *****/
      class Ship {
        constructor() {
          this.x = canvas.width / 2;
          this.y = canvas.height / 2;
          this.radius = 15;
          this.angle = 0;
          this.rotation = 0;
          this.velocity = { x: 0, y: 0 };
          this.thrusting = false;
        }
        update() {
          if (keys["ArrowLeft"]) this.rotation = -config.ship.rotationSpeed;
          else if (keys["ArrowRight"]) this.rotation = config.ship.rotationSpeed;
          else this.rotation = 0;
          this.angle += this.rotation;
          if (keys["ArrowUp"]) {
            this.thrusting = true;
            const force = {
              x: Math.cos(this.angle) * config.ship.acceleration,
              y: Math.sin(this.angle) * config.ship.acceleration
            };
            this.velocity.x += force.x;
            this.velocity.y += force.y;
            for (let i = 0; i < config.particles.thruster.count; i++) {
              const offsetAngle = this.angle + Math.PI + (Math.random() - 0.5) * 0.4;
              particles.push(new Particle(
                this.x - Math.cos(this.angle) * 20,
                this.y - Math.sin(this.angle) * 20,
                offsetAngle,
                config.particles.thruster.speed * (Math.random() + 0.5),
                config.particles.thruster.life,
                config.particles.thruster.color,
                config.particles.thruster.size
              ));
            }
            // Start sustained thrust sound if not already playing.
            osc.startSustainedSound("thrust", config.sounds.thrust.frequency, config.sounds.thrust.type, config.sounds.thrust.volume);
          } else {
            this.thrusting = false;
            osc.stopSustainedSound("thrust");
            // Apply drag / friction when not thrusting.
            this.velocity.x *= config.ship.drag;
            this.velocity.y *= config.ship.drag;
          }
          const speed = Math.hypot(this.velocity.x, this.velocity.y);
          if (speed > config.ship.maxVelocity) {
            this.velocity.x = (this.velocity.x / speed) * config.ship.maxVelocity;
            this.velocity.y = (this.velocity.y / speed) * config.ship.maxVelocity;
          }
          this.x += this.velocity.x;
          this.y += this.velocity.y;
          if (this.x < 0) this.x = canvas.width;
          if (this.x > canvas.width) this.x = 0;
          if (this.y < 0) this.y = canvas.height;
          if (this.y > canvas.height) this.y = 0;
        }
        draw() {
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.rotate(this.angle);
          ctx.strokeStyle = "#0f0";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(20, 0);
          ctx.lineTo(-10, -10);
          ctx.lineTo(-10, 10);
          ctx.closePath();
          ctx.stroke();
          if (this.thrusting) {
            ctx.beginPath();
            ctx.moveTo(-10, -5);
            ctx.lineTo(-18, 0);
            ctx.lineTo(-10, 5);
            ctx.strokeStyle = "blue";
            ctx.stroke();
          }
          ctx.restore();
        }
      }

      /***** Asteroid Class *****/
      class Asteroid {
        constructor(x, y, radius, level = 0) {
          this.x = x;
          this.y = y;
          this.radius = radius;
          this.level = level;
          this.angle = Math.random() * Math.PI * 2;
          this.velocity = {
            x: (Math.random() - 0.5) * (2 - level),
            y: (Math.random() - 0.5) * (2 - level)
          };
          this.vertices = [];
          const count = Math.floor(Math.random() * 5) + 5;
          for (let i = 0; i < count; i++) {
            const offset = Math.random() * this.radius / 2;
            this.vertices.push(this.radius - offset);
          }
        }
        update() {
          this.x += this.velocity.x;
          this.y += this.velocity.y;
          if (this.x < 0) this.x = canvas.width;
          if (this.x > canvas.width) this.x = 0;
          if (this.y < 0) this.y = canvas.height;
          if (this.y > canvas.height) this.y = 0;
        }
        draw() {
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.strokeStyle = "#0f0";
          ctx.lineWidth = 2;
          ctx.beginPath();
          const count = this.vertices.length;
          for (let i = 0; i < count; i++) {
            const angle = (i / count) * Math.PI * 2;
            const r = this.vertices[i];
            const x = Math.cos(angle) * r;
            const y = Math.sin(angle) * r;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
          ctx.stroke();
          ctx.restore();
        }
      }

      /***** Bullet Class *****/
      class Bullet {
        constructor(x, y, angle) {
          this.x = x;
          this.y = y;
          this.angle = angle;
          this.velocity = {
            x: Math.cos(angle) * config.bullet.speed,
            y: Math.sin(angle) * config.bullet.speed
          };
          this.radius = 2;
          this.life = config.bullet.life;
          this.from = "player";
          this.color = "#0f0";
        }
        update() {
          this.x += this.velocity.x;
          this.y += this.velocity.y;
          this.life--;
        }
        draw() {
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      /***** UFO Class *****/
      class UFO {
        constructor() {
          this.fromLeft = Math.random() < 0.5;
          this.x = this.fromLeft ? -50 : canvas.width + 50;
          this.y = Math.random() * canvas.height * 0.3;
          this.speed = config.ufo.speed;
          this.shootCooldown = config.ufo.shootCooldown;
          this.radius = 30;
        }
        update() {
          this.fromLeft ? this.x += this.speed : this.x -= this.speed;
          this.shootCooldown--;
          if(this.shootCooldown <= 0 && ship) {
            const angle = Math.atan2(ship.y - this.y, ship.x - this.x);
            const bullet = new Bullet(this.x, this.y, angle);
            bullet.from = "ufo";
            bullet.color = "red";
            bullets.push(bullet);
            osc.playSound(config.sounds.ufoShoot.frequency, config.sounds.ufoShoot.type, config.sounds.ufoShoot.duration, config.sounds.ufoShoot.volume);
            this.shootCooldown = config.ufo.shootCooldown;
          }
          if(this.x < -100 || this.x > canvas.width + 100) ufo = null;
        }
        draw() {
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.strokeStyle = "#f0f";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.ellipse(0, 0, 30, 15, 0, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(0, -5, 15, Math.PI, 2 * Math.PI);
          ctx.stroke();
          ctx.restore();
        }
      }
      let ufo = null;
      let ufoSpawnTimer = 300;

      /***** Create Initial Asteroids *****/
      function createAsteroids(count) {
        asteroids = [];
        for (let i = 0; i < count; i++) {
          let x, y;
          do {
            x = Math.random() * canvas.width;
            y = Math.random() * canvas.height;
          } while (Math.hypot(x - canvas.width/2, y - canvas.height/2) < 100);
          asteroids.push(new Asteroid(x, y, config.asteroid.defaultRadius));
        }
      }

      /***** Collision Detection *****/
      function isColliding(a, b) {
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        return Math.hypot(dx, dy) < a.radius + b.radius;
      }

      /***** Handle Shooting (Space Key) *****/
      document.addEventListener("keydown", (e) => {
        if (e.key === " " && gameState === "playing") {
          bullets.push(new Bullet(
            ship.x + Math.cos(ship.angle) * 20,
            ship.y + Math.sin(ship.angle) * 20,
            ship.angle
          ));
          osc.playSound(config.sounds.bullet.frequency, config.sounds.bullet.type, config.sounds.bullet.duration, config.sounds.bullet.volume);
        }
      });

      /***** Update Function *****/
      function update() {
        if (gameState === "playing") {
          ship.update();
          asteroids.forEach(a => a.update());
          bullets.forEach((b, bIdx) => {
            b.update();
            if (b.life <= 0) bullets.splice(bIdx, 1);
          });
          if (!ufo) {
            ufoSpawnTimer--;
            if(ufoSpawnTimer <= 0) {
              ufo = new UFO();
              ufoSpawnTimer = Math.floor(Math.random() * 300) + 300;
            }
          } else {
            ufo.update();
          }
          bullets.forEach((b, bIdx) => {
            asteroids.forEach((a, aIdx) => {
              if (isColliding(b, a)) {
                score += 10;
                for (let i = 0; i < config.particles.explosion.count; i++) {
                  particles.push(new Particle(
                    a.x, a.y,
                    Math.random() * Math.PI * 2,
                    config.particles.explosion.speed * (Math.random() + 0.5),
                    config.particles.explosion.life,
                    config.particles.explosion.color,
                    config.particles.explosion.size
                  ));
                }
                effects.push(new Ring(a.x, a.y, 0, a.radius * 3, config.particles.explosion.life, config.particles.explosion.color, 2));
                bullets.splice(bIdx, 1);
                asteroids.splice(aIdx, 1);
                osc.playSound(config.sounds.asteroidExplosion.frequency, config.sounds.asteroidExplosion.type, config.sounds.asteroidExplosion.duration, config.sounds.asteroidExplosion.volume);
                if (a.radius > 20) {
                  asteroids.push(new Asteroid(a.x, a.y, a.radius / 2));
                  asteroids.push(new Asteroid(a.x, a.y, a.radius / 2));
                }
              }
            });
            if(b.from === "player" && ufo) {
              const dx = b.x - ufo.x, dy = b.y - ufo.y;
              if(Math.hypot(dx, dy) < ufo.radius + b.radius) {
                score += config.ufo.scoreValue;
                for (let i = 0; i < config.particles.explosion.count; i++) {
                  particles.push(new Particle(
                    ufo.x, ufo.y,
                    Math.random() * Math.PI * 2,
                    config.particles.explosion.speed * (Math.random() + 0.5),
                    config.particles.explosion.life,
                    config.particles.explosion.color,
                    config.particles.explosion.size
                  ));
                }
                effects.push(new Ring(ufo.x, ufo.y, 0, ufo.radius * 3, config.particles.explosion.life, config.particles.explosion.color, 2));
                bullets.splice(bIdx, 1);
                ufo = null;
                osc.playSound(config.sounds.ufoExplosion.frequency, config.sounds.ufoExplosion.type, config.sounds.ufoExplosion.duration, config.sounds.ufoExplosion.volume);
              }
            }
            if(b.from === "ufo" && ship) {
              const dx = b.x - ship.x, dy = b.y - ship.y;
              if(Math.hypot(dx, dy) < ship.radius + b.radius) {
                gameOver();
              }
            }
          });
          asteroids.forEach(a => {
            if (isColliding(a, ship)) {
              gameOver();
            }
          });
          updateStars();
        }
        particles.forEach((p, idx) => {
          p.update();
          if (p.life <= 0) particles.splice(idx, 1);
        });
        effects.forEach((e, idx) => {
          e.update();
          if (e.life <= 0) effects.splice(idx, 1);
        });
      }

      /***** Draw Score *****/
      function drawScore() {
        ctx.save();
        ctx.font = config.score.font;
        ctx.strokeStyle = config.score.color;
        ctx.lineWidth = 1;
        ctx.strokeText("SCORE: " + score, 20, 40);
        ctx.restore();
      }

      /***** Draw Function *****/
      function draw() {
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawStars();
        if (gameState === "playing") {
          ctx.save();
          ctx.shadowBlur = 10;
          ctx.shadowColor = "#0f0";
          ship.draw();
          ctx.restore();
          ctx.save();
          ctx.shadowBlur = 8;
          ctx.shadowColor = "#0f0";
          asteroids.forEach(a => a.draw());
          ctx.restore();
          ctx.save();
          ctx.shadowBlur = 15;
          bullets.forEach(b => {
            ctx.shadowColor = b.color;
            b.draw();
          });
          ctx.restore();
          if(ufo) {
            ctx.save();
            ctx.shadowBlur = 15;
            ctx.shadowColor = "#f0f";
            ufo.draw();
            ctx.restore();
          }
        }
        particles.forEach(p => p.draw());
        effects.forEach(e => e.draw());
        ctx.save();
        ctx.shadowBlur = 10;
        ctx.shadowColor = config.score.color;
        drawScore();
        ctx.restore();
      }

      /***** Main Game Loop *****/
      function gameLoop() {
        update();
        draw();
        requestAnimationFrame(gameLoop);
      }

      /***** Game Start with Beam-In Effect *****/
      function startGame() {
        // Clear previous game objects
        bullets = [];
        particles = [];
        effects = [];
        asteroids = [];
        score = 0;
        select("startScreen").style.display = "none";
        select("gameOverScreen").style.display = "none";
        select("creditsScreen").style.display = "none";
        
        // Create asteroids immediately
        createAsteroids(config.asteroid.initialCount);
        
        // Start background sound loop
        osc.startSustainedSound("background", config.sounds.background.frequency, config.sounds.background.type, config.sounds.background.volume);
        
        // Use a beam-in effect: create a stream of blue rings.
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const diag = Math.hypot(canvas.width, canvas.height);
        const beamCount = 10; // Number of rings to spawn.
        for (let i = 0; i < beamCount; i++) {
          setTimeout(() => {
            effects.push(new Ring(centerX, centerY, diag, 0, config.particles.shipExplosion.ringLife, config.particles.shipExplosion.color, config.particles.shipExplosion.lineWidth, true));
          }, i * 50);
        }
        
        // Set game state to "starting" until beam effect completes.
        gameState = "starting";
        setTimeout(() => {
          ship = new Ship();
          gameState = "playing";
        }, config.particles.shipExplosion.ringLife * 16);
      }

      /***** Game Over Routine *****/
      function gameOver() {
        if (gameState !== "playing") return;
        gameState = "gameover";
        // Stop background sound.
        osc.stopSustainedSound("background");
        for (let i = 0; i < config.particles.shipExplosion.count; i++) {
          particles.push(new Particle(
            ship.x, ship.y,
            Math.random() * Math.PI * 2,
            config.particles.explosion.speed * (Math.random() + 0.5),
            config.particles.explosion.life,
            config.particles.explosion.color,
            config.particles.explosion.size
          ));
        }
        effects.push(new Ring(
          ship.x, ship.y,
          0, Math.hypot(canvas.width, canvas.height),
          config.particles.shipExplosion.ringLife,
          config.particles.shipExplosion.color,
          config.particles.shipExplosion.lineWidth
        ));
        osc.playSound(config.sounds.shipExplosion.frequency, config.sounds.shipExplosion.type, config.sounds.shipExplosion.duration, config.sounds.shipExplosion.volume);
        setTimeout(() => {
          select("gameOverScreen").style.display = "flex";
        }, 500);
      }

      /***** Button Event Listeners Using on() *****/
      on("startBtn", "click", () => {
        startGame();
        initStars();
      });
      on("restartBtn", "click", () => {
        startGame();
        initStars();
      });
      on("creditsBtn", "click", () => {
        select("gameOverScreen").style.display = "none";
        select("creditsScreen").style.display = "flex";
      });
      on("backToMenuBtn", "click", () => {
        select("creditsScreen").style.display = "none";
        select("startScreen").style.display = "flex";
      });

      /***** Start the Game Loop *****/
      requestAnimationFrame(gameLoop);
    })();
  </script>
</body>
</html>
